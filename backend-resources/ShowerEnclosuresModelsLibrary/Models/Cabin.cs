using System;
using System.Collections.Generic;
using System.IO.IsolatedStorage;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Schema;
using CommonInterfacesBronze;
using FluentValidation.Results;
using ShowerEnclosuresModelsLibrary.Builder;
using ShowerEnclosuresModelsLibrary.Enums;
using ShowerEnclosuresModelsLibrary.Enums.CabinCategories;
using ShowerEnclosuresModelsLibrary.Enums.ShowerDrawEnums;
using ShowerEnclosuresModelsLibrary.Factory;
using ShowerEnclosuresModelsLibrary.Models.CabinAllParts.PartsModels;
using ShowerEnclosuresModelsLibrary.Models.SeriesModels;
using ShowerEnclosuresModelsLibrary.Validators;
using ShowerEnclosuresModelsLibrary.Validators.WSValidator;
using static ShowerEnclosuresModelsLibrary.Helpers.HelperMethods;

namespace ShowerEnclosuresModelsLibrary.Models;

/// <summary>
/// Cabins Super Class
/// </summary>
public abstract class Cabin : IAutoGeneratedCodeable, IDeepClonable<Cabin>
{
    /// <summary>
    /// The Parts of this Cabin
    /// </summary>
    public abstract CabinPartsList Parts { get; }
    /// <summary>
    /// The Constraints of this Cabin
    /// </summary>
    public abstract CabinConstraints Constraints { get; }
    /// <summary>
    /// The Cabin Model (Defines Both Series and Series Model)
    /// </summary>
    public CabinModelEnum? Model { get; set; }                                   //Each Derived Class sets it in its constructor
    
    /// <summary>
    /// The Finish of the Metal Parts of the Cabin
    /// </summary>
    public CabinFinishEnum? MetalFinish { get; set; } = CabinFinishEnum.Polished;          //Finish of Parts except Glass

    /// <summary>
    /// The Thickness of the Glasses of the Cabin
    /// </summary>
    public CabinThicknessEnum? Thicknesses { get; set; }                                   //Combinations of Glasses Thickness (1st is always the Fixed Part)
    
    /// <summary>
    /// The Finish of the Glasses of the Cabin
    /// </summary>
    public GlassFinishEnum? GlassFinish { get; set; }                                      //The Finish of the Glasses

    /// <summary>
    /// The Glasses of the Cabin (Dimensions Finish e.t.c.)
    /// </summary>
    public List<Glass> Glasses { get; set; } = new();                                      //Should be calculated each time the Calculations are Valid

    /// <summary>
    /// The Backing Field of the Overriden Code
    /// </summary>
    private string overridenCode = string.Empty;
    /// <summary>
    /// The SKU-Code of the Cabin
    /// </summary>
    public string Code 
    { 
        get => IsCodeOverriden ? overridenCode : GetGeneratedCode();
    }                                                
    /// <summary>
    /// Weather the Cabin Code should be Overriden
    /// </summary>
    public bool IsCodeOverriden { get; set; } = false;
    /// <summary>
    /// Overrides the AutoGenerated Code
    /// </summary>
    /// <param name="code"></param>
    public void OverrideCode(string code)
    {
        if (string.IsNullOrWhiteSpace(code))
        {
            IsCodeOverriden = false;
        }
        else
        {
            IsCodeOverriden = true;
        }
        overridenCode = code;
    }
    /// <summary>
    /// Stops overriding the Code and Produces it Automatically
    /// </summary>
    public void UseAutoCode()
    {
        IsCodeOverriden = false;
    }

    /// <summary>
    /// The Opening of the Cabin when its Door/s are Open -- Zero for Doorless Cabins
    /// </summary>
    public double Opening { get=>GetOpening();}                                               //Opening
    
    /// <summary>
    /// Wheather this cabin has a step Cut
    /// </summary>
    public virtual bool HasStep { get=> Extras.Any(e => e.ExtraType == CabinExtraType.StepCut); }   //Check if the Cabin Has Step
    
    /// <summary>
    /// The Series of the Cabin
    /// </summary>
    public abstract CabinSeries Series { get;}                                             //The Model Series (Configured in Each Model Seperately)

    /// <summary>
    /// The Extras of the Cabin (BClean,SafeKids,Cuts e.t.c.)
    /// </summary>
    public List<CabinExtra> Extras { get; private set; } = new();

    /// <summary>
    /// Defines The Draw That this Cabin is Part Of
    /// </summary>
    public CabinDrawNumber IsPartOfDraw { get; set; }

    /// <summary>
    /// The Synthesis Model No of this Cabin
    /// </summary>
    public CabinSynthesisModel SynthesisModel { get; set; }

    /// <summary>
    /// The Position of the Fixed Part when Looking the Cabin From the Outside.
    /// If there is No Fixed Part , then the Position of the Door
    /// </summary>
    public CabinDirection Direction { get; set; }

    /// <summary>
    /// Wheather the Cabin can be Reversed
    /// </summary>
    public bool IsReversible { get; set; }

    #region 1.DIMENSIONS
    /// <summary>
    /// The Nominal Length (Median Length)
    /// </summary>
    public int NominalLength { get; set; }

    /// <summary>
    /// The Maximum Length that can Be Achieved for the Cabin (MinLength must be Set)
    /// </summary>
    public int LengthMax { get => GetMaximumLength(); set => SetMaxLength(value); }
    /// <summary>
    /// The Minimum/Starting Length of the Cabin
    /// </summary>
    public int LengthMin { get=> GetMinLength(); set => SetMinLength(value); }
    /// <summary>
    /// The Height of the Cabin
    /// </summary>
    public int Height { get; set; }

    /// <summary>
    /// The Minus Tollerance of the Cabin
    /// Calculated From Total Tollerance and Default Minimum
    /// </summary>
    public int TolleranceMinus
    {
        get
        {
            //Return the Default Minimum if the Total tollerance is enough
            if ((TotalTollerance - Constraints.TolleranceMinusDefaultMinimum) > 0)
            {
                return Constraints.TolleranceMinusDefaultMinimum;
            }
            return TotalTollerance;
        }
    }
    /// <summary>
    /// The Plus Tollerance of the Cabin
    /// </summary>
    public int TollerancePlus
    {
        get
        {
            if ((TotalTollerance - TolleranceMinus) > 0)
            {
                return TotalTollerance - TolleranceMinus;
            }
            return 0;
        }
    }
    /// <summary>
    /// The Total Tolerance of the Cabin
    /// </summary>
    public virtual int TotalTollerance { get => totalTolleranceAdjustment; }
    /// <summary>
    /// An Adjustment to the Total Tollerance
    /// </summary>
    protected int totalTolleranceAdjustment = 0;
    public void SetTotalTolleranceAdjustment(int adjustment)
    {
        totalTolleranceAdjustment = adjustment;
    }

    #endregion

    public Cabin()
    {

    }

    /// <summary>
    /// Gets the StepCut for this Cabin or Null if there is not one
    /// </summary>
    /// <returns>StepCut or null</returns>
    public virtual StepCut GetStepCut()
    {
        StepCut step = (StepCut)Extras.Find(e => e.ExtraType == CabinExtraType.StepCut);
        return step;
    }

    /// <summary>
    /// Checks if there is a specific extra in the Cabin
    /// </summary>
    /// <param name="extraType">The Extra Type</param>
    /// <returns>True if there is , false if there is not</returns>
    public virtual bool HasExtra(CabinExtraType extraType)
    {
        return Extras.Any(e => e.ExtraType == extraType);
    }

    /// <summary>
    /// Get the Maximum Length that this Cabin can have
    /// </summary>
    /// <returns></returns>
    protected virtual int GetMaximumLength()
    {
        if (NominalLength >= 0)
        {
            int maximumLength = NominalLength + TollerancePlus;
            return maximumLength;
        }
        else
        {
            return 0;
        }
    }
    /// <summary>
    /// Get the Nominal Length that this Cabin Has
    /// </summary>
    /// <returns></returns>
    protected virtual int GetMinLength()
    {
        if (NominalLength >= TolleranceMinus)
        {
            int lengthMin = NominalLength - TolleranceMinus;
            return lengthMin;
        }
        else
        {
            return 0;
        }
    }

    /// <summary>
    /// Sets the Nominal Length By Setting the Length Min 
    /// Tollerance must have been set before 
    /// </summary>
    /// <param name="value">The Nominal Length Value</param>
    protected virtual void SetMinLength(int value)
    {
        if (value != LengthMin && value >= 0)
        {
            //When value is smaller than the tollerance then set Length Min to Zero
            NominalLength = value + TolleranceMinus;
        }
        else
        {
            NominalLength = 0;
        }
    }

    /// <summary>
    /// Sets the Nominal Length by Setting the Length Max Tollerance , must have been set Before
    /// </summary>
    /// <param name="value">The Value of the MaxLength</param>
    protected virtual void SetMaxLength(int value)
    {
        if (value != LengthMax && value >= TollerancePlus)
        {
            //When value is smaller than the tollerance then set Length Min to Zero
            NominalLength = value - TollerancePlus;
        }
        else
        {
            NominalLength = 0;
        }
    }

    /// <summary>
    /// Get the AutoGenerated Code for this Cabin
    /// </summary>
    /// <returns></returns>
    public string GetGeneratedCode()
    {
        return Helpers.CodeGenerator.GenerateCabinCode(this);
    }

    /// <summary>
    /// Get the Cabin Opening
    /// </summary>
    /// <returns></returns>
    protected abstract double GetOpening();

    /// <summary>
    /// Add a Cabin Extra
    /// </summary>
    /// <param name="type">The Type of Extra To Add</param>
    public void AddExtra(CabinExtraType type)
    {
        Extras.Add(CabinExtrasFactory.CreateCabinExtra(type));
    }

    /// <summary>
    /// Remove an Extra if it exists  -- Removes the First Found extra
    /// </summary>
    /// <param name="type">The Type of extra to Remove</param>
    public void RemoveExtra(CabinExtraType type)
    {
        if (Extras.Any(e=>e.ExtraType == type))
        {
            Extras.Remove(Extras.First(e => e.ExtraType == type));
        }
    }

    /// <summary>
    /// Clear All Extras
    /// </summary>
    public void ClearExtras()
    {
        Extras.Clear();
    }

    /// <summary>
    /// Checks wheather an object is equal to this Cabin 
    /// Meaning having all Basic Properties the Same -- All Extras The Same
    /// DOES NOT COMPARE SPECIFIC INTERNAL PROPERTIES OF EACH SUBCLASS
    /// </summary>
    /// <param name="obj"></param>
    /// <returns>TRUE if the same , False Otherwise </returns>
    //public override bool Equals(object obj)
    //{
    //    if ((obj is null) || this.GetType().Equals(obj.GetType()) is false)
    //    {
    //        return false;
    //    }
    //    else
    //    {
    //        Cabin cabin = obj as Cabin ?? throw new NullReferenceException("Equality Object is Null");
    //        bool areEqualBasicProps =
    //            (this.Model == cabin.Model) &&
    //            (this.MetalFinish == cabin.MetalFinish) &&
    //            (this.GlassFinish == cabin.GlassFinish) &&
    //            (this.Series == cabin.Series) &&
    //            (this.LengthMin == cabin.LengthMin) &&
    //            (this.Height == cabin.Height);

    //        if (areEqualBasicProps is false)
    //        {
    //            return false;
    //        }

    //        //Return fase if the do not have same extras
    //        foreach (CabinExtraType extra in Enum.GetValues(typeof(CabinExtraType)))
    //        {
    //            bool haveSameExtras = this.HasExtra(extra) == cabin.HasExtra(extra);
    //            if (haveSameExtras is false)
    //            {
    //                return false;
    //            }
    //        }

    //        if (this.HasStep && cabin.HasStep)
    //        {
    //            if ((this.GetStepCut().StepLength != cabin.GetStepCut().StepLength)
    //                || this.GetStepCut().StepHeight != cabin.GetStepCut().StepHeight)
    //            {
    //                return false;
    //            }
    //        }

    //        return true;
    //    }
    //}

    /// <summary>
    /// Returns the HashCode for this Item
    /// </summary>
    /// <returns></returns>
    //public override int GetHashCode()
    //{
    //    return HashCode.Combine(
    //        Model, 
    //        MetalFinish, 
    //        Thicknesses, 
    //        GlassFinish, 
    //        LengthMin, 
    //        Height, 
    //        Extras,
    //        SynthesisModel);
    //}

    /// <summary>
    /// Represents the Dimensions of the Cabin as a String
    /// </summary>
    /// <returns></returns>
    public string ToString(CabinStringRepresentation stringRepresentation)
    {
        StringBuilder builder = new();
        string thickness = Thicknesses switch
        {
            CabinThicknessEnum.NotSet => "??mm",
            CabinThicknessEnum.Thick5mm => "5mm",
            CabinThicknessEnum.Thick6mm => "6mm",
            CabinThicknessEnum.Thick6mm8mm => "6-8mm",
            CabinThicknessEnum.Thick8mm => "8mm",
            CabinThicknessEnum.Thick8mm10mm => "8-10mm",
            CabinThicknessEnum.Thick10mm => "10mm",
            CabinThicknessEnum.ThickTenplex10mm => "T10mm",
            _ => "??mm",
        };

        builder.Append(NominalLength)
               .Append('x')
               .Append(Height)
               .Append('x')
               .Append(thickness);
        return builder.ToString();
    }

    public override string ToString()
    {
        return ToString(CabinStringRepresentation.DefaultOnlyDimensions);
    }

    /// <summary>
    /// Returns a Deep Copy of this Cabin
    /// </summary>
    /// <returns></returns>
    public abstract Cabin GetDeepClone();

    public enum CabinStringRepresentation
    {
        DefaultOnlyDimensions = 0,
    }

    /// <summary>
    /// Copies the properties of the Base to the provided Cabin and returns it
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="cabin"></param>
    /// <returns></returns>
    protected T CopyBaseProperties<T>(T cabin) where T : Cabin
    {
        cabin.Model = this.Model;
        cabin.MetalFinish = this.MetalFinish;
        cabin.Thicknesses = this.Thicknesses;
        cabin.GlassFinish = this.GlassFinish;
        cabin.IsPartOfDraw = this.IsPartOfDraw;
        cabin.SynthesisModel = this.SynthesisModel;
        cabin.Direction = this.Direction;
        cabin.IsReversible = this.IsReversible;
        cabin.NominalLength = this.NominalLength;
        cabin.Height = this.Height;

        foreach (Glass glass in this.Glasses)
        {
            cabin.Glasses.Add(glass.GetDeepClone());
        }

        foreach (CabinExtra extra in this.Extras)
        {
            cabin.Extras.Add(extra.GetDeepClone());
        }

        cabin.SetTotalTolleranceAdjustment(this.totalTolleranceAdjustment);
        return cabin;
    }

    public bool HasGlassDoor()
    {
        return this.Glasses.Any(g => g.GlassType == GlassTypeEnum.DoorGlass);
    }
    public bool HasFixedGlass()
    {
        return this.Glasses.Any(g => g.GlassType == GlassTypeEnum.FixedGlass);
    }

    public static Cabin Empty()
    {
        return new UndefinedCabin();
    }
}

public class UndefinedCabin : Cabin
{
    public override CabinPartsList Parts { get; } = new();
    public override CabinConstraints Constraints { get; } = new UndefinedConstraints();
    public override CabinSeries Series { get; }


    public UndefinedCabin()
    {
        Model = CabinModelEnum.ModelGlassContainer;
        IsPartOfDraw = CabinDrawNumber.None;
        GlassFinish = GlassFinishEnum.GlassFinishNotSet;
        Thicknesses = CabinThicknessEnum.NotSet;
    }

    public override Cabin GetDeepClone()
    {
        throw new NotSupportedException($"{nameof(GetDeepClone)} is not supported in an {nameof(UndefinedCabin)}");
    }

    protected override double GetOpening()
    {
        throw new NotSupportedException($"{nameof(GetOpening)} is not supported in an {nameof(UndefinedCabin)}");
    }
}

